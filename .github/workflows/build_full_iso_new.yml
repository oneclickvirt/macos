name: MacOS ISO Builder For OpenCore

on:
  workflow_dispatch:

jobs:
  build_iso:
    runs-on: macos-latest
    strategy:
      fail-fast: false
      max-parallel: 1
      matrix:
        include:
          - macos_version: "20G1427"
            macos_name: "big-sur"
            macos_version_number: "11.7"
            catalog: "publicrelease"
          - macos_version: "21H1123"
            macos_name: "monterey"
            macos_version_number: "12"
            catalog: "publicrelease"
          - macos_version: "22H313"
            macos_name: "ventura"
            macos_version_number: "13"
            catalog: "publicrelease"
          - macos_version: "23H311"
            macos_name: "sonoma"
            macos_version_number: "14"
            catalog: "publicrelease"
          - macos_version: "24C101"
            macos_name: "sequoia"
            macos_version_number: "15"
            catalog: "publicrelease"

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Install dependencies
        run: |
          brew install wget sshpass p7zip cpio

      - name: Clone gibMacOS
        run: |
          git clone https://github.com/corpnewt/gibMacOS.git gibMacOS
          chmod +x gibMacOS/gibMacOS.command

      - name: Download macOS components
        working-directory: gibMacOS
        run: |
          python3 gibMacOS.py --catalog "${{ matrix.catalog }}" \
                             --version "${{ matrix.macos_version_number }}" \
                             -b "${{ matrix.macos_version }}"

      - name: Determine download directory
        id: find_dir
        run: |
          DIR=$(find "${GITHUB_WORKSPACE}/gibMacOS/macOS Downloads" -type d -name "*${{ matrix.macos_version }}*" | head -n1)
          if [ -z "$DIR" ]; then echo "Error: download dir not found"; exit 1; fi
          echo "DOWNLOAD_DIR=$DIR" >> $GITHUB_ENV
          echo "Download directory: $DIR"
          ls -la "$DIR"

      - name: Prepare installer app
        run: |
          MAJOR=$(echo "${{ matrix.macos_version_number }}" | cut -d. -f1)
          
          # Find the installer package
          PKG=$(find "$DOWNLOAD_DIR" -name "InstallAssistant.pkg" | head -n1)
          if [ -z "$PKG" ]; then
            echo "Error: InstallAssistant.pkg not found"
            ls -la "$DOWNLOAD_DIR"
            exit 1
          fi
          
          echo "Found installer package: $PKG"
          
          # Create a temporary directory for extraction
          EXTRACT_DIR=$(mktemp -d)
          echo "Extracting package to: $EXTRACT_DIR"
          
          # Extract the package using pkgutil
          sudo pkgutil --expand "$PKG" "$EXTRACT_DIR/pkg_expanded"
          
          # Find all payload files and extract them
          FOUND_APP=0
          for PAYLOAD in $(find "$EXTRACT_DIR/pkg_expanded" -name "Payload"); do
            echo "Processing payload: $PAYLOAD"
            PAYLOAD_DIR=$(mktemp -d)
            
            # Try different extraction methods
            (cd "$PAYLOAD_DIR" && cat "$PAYLOAD" | gunzip -dc | cpio -i 2>/dev/null) || \
            (cd "$PAYLOAD_DIR" && 7z x "$PAYLOAD" -y >/dev/null 2>&1) || \
            (cd "$PAYLOAD_DIR" && xar -xf "$PAYLOAD" 2>/dev/null) || \
            echo "Warning: Could not extract $PAYLOAD"
            
            # Look for the Install macOS app
            APP=$(find "$PAYLOAD_DIR" -type d -name "Install*.app" | head -n1)
            if [ -n "$APP" ]; then
              echo "Found installer app: $APP"
              mkdir -p installer_app
              cp -R "$APP" installer_app/
              FOUND_APP=1
              break
            fi
            
            # Clean up
            rm -rf "$PAYLOAD_DIR"
          done
          
          # If app not found in payload, try extracting SharedSupport.dmg from the package
          if [ $FOUND_APP -eq 0 ]; then
            echo "Trying to extract SharedSupport.dmg..."
            DMG=$(find "$EXTRACT_DIR" -name "SharedSupport.dmg" | head -n1)
            
            if [ -n "$DMG" ]; then
              echo "Found SharedSupport.dmg: $DMG"
              DMG_MOUNT=$(mktemp -d)
              hdiutil attach "$DMG" -mountpoint "$DMG_MOUNT" -nobrowse
              
              APP=$(find "$DMG_MOUNT" -type d -name "Install*.app" | head -n1)
              if [ -n "$APP" ]; then
                echo "Found installer app in DMG: $APP"
                mkdir -p installer_app
                cp -R "$APP" installer_app/
                FOUND_APP=1
              fi
              
              hdiutil detach "$DMG_MOUNT" -force || true
              rm -rf "$DMG_MOUNT"
            fi
          fi
          
          # If still no app found, try download using softwareupdate
          if [ $FOUND_APP -eq 0 ]; then
            echo "Attempting to download installer using softwareupdate..."
            sudo softwareupdate --fetch-full-installer --full-installer-version "${{ matrix.macos_version_number }}"
            
            # Look for the downloaded installer in /Applications
            APP=$(find "/Applications" -maxdepth 1 -type d -name "Install macOS*.app" | grep -i "${{ matrix.macos_name }}" | head -n1)
            if [ -n "$APP" ]; then
              echo "Found installer app using softwareupdate: $APP"
              mkdir -p installer_app
              sudo cp -R "$APP" installer_app/
              sudo chown -R $(whoami) installer_app
              FOUND_APP=1
            fi
          fi
          
          # Final check for installer app
          if [ $FOUND_APP -eq 0 ]; then
            echo "Error: Could not find or create a valid installer app"
            exit 1
          fi
          
          # Find the final installer app path
          INSTALLER_APP=$(find "$(pwd)/installer_app" -type d -name "Install*.app" | head -n1)
          if [ ! -d "$INSTALLER_APP" ]; then
            echo "Error: Invalid installer application path: $INSTALLER_APP"
            exit 1
          fi
          
          echo "Using installer app: $INSTALLER_APP"
          ls -la "$INSTALLER_APP"
          ls -la "$INSTALLER_APP/Contents/Resources" || echo "Resources directory not found"
          
          # Verify createinstallmedia exists
          if [ ! -f "$INSTALLER_APP/Contents/Resources/createinstallmedia" ]; then
            echo "Error: createinstallmedia not found in $INSTALLER_APP"
            exit 1
          fi
          
          # Make sure createinstallmedia is executable
          sudo chmod +x "$INSTALLER_APP/Contents/Resources/createinstallmedia"
          
          echo "INSTALLER_APP=$INSTALLER_APP" >> $GITHUB_ENV
          
          # Clean up with proper permissions
          sudo rm -rf "$EXTRACT_DIR" || {
            echo "Warning: Could not remove extraction directory. Continuing..."
          }

      - name: Create sparse image with dynamic size
        run: |
          DOWNLOAD_SIZE=$(du -sk "$DOWNLOAD_DIR" | awk '{print $1}')
          DOWNLOAD_SIZE_GB=$(( (DOWNLOAD_SIZE + 1048576) / 1048576 ))
          IMAGE_SIZE="${DOWNLOAD_SIZE_GB}g"
          echo "Creating sparse image with size: $IMAGE_SIZE"
          hdiutil create -size $IMAGE_SIZE -layout GPTSPUD -fs HFS+J -type SPARSE \
            -volname "Install_${{ matrix.macos_name }}" \
            -o temp_install.sparseimage

      - name: Attach sparse image
        id: attach
        run: |
          # First attempt to attach
          for attempt in {1..3}; do
            echo "Attachment attempt $attempt..."
            OUTPUT=$(hdiutil attach temp_install.sparseimage -nobrowse -noverify -noautoopen)
            echo "Attachment output: $OUTPUT"
            
            EFI_LINE=$(echo "$OUTPUT" | grep -i "EFI ")
            INSTALL_LINE=$(echo "$OUTPUT" | grep -i "Install_${{ matrix.macos_name }}")
            
            if [[ -n "$INSTALL_LINE" ]]; then
              echo "Install volume found on attempt $attempt"
              break
            else
              echo "Install volume not found, retrying after delay..."
              sleep 10
            fi
          done
          
          # Check if we have the necessary volumes
          if [[ -z "$INSTALL_LINE" ]]; then
            echo "Error: Could not attach install volume after multiple attempts"
            
            # List all volumes to debug
            echo "All mounted volumes:"
            df -h
            diskutil list
            
            # Force attach again with more details
            echo "Forcing attach with more debug info:"
            hdiutil attach temp_install.sparseimage -nobrowse -noverify -noautoopen -debug
            
            # Try to find volumes again
            OUTPUT=$(mount | grep -E "Install|EFI")
            echo "Found mounted volumes: $OUTPUT"
            
            EFI_LINE=$(echo "$OUTPUT" | grep -i "EFI ")
            INSTALL_LINE=$(echo "$OUTPUT" | grep -i "Install")
          fi
          
          # Extract device names and mount points
          EFI_DEV=$(echo "$EFI_LINE" | awk '{print $1}')
          EFI_MNT=$(echo "$EFI_LINE" | awk '{print $3}')
          INST_DEV=$(echo "$INSTALL_LINE" | awk '{print $1}')
          INST_MNT=$(echo "$INSTALL_LINE" | awk '{print $3}')
          
          echo "EFI device: $EFI_DEV"
          echo "EFI mount point: $EFI_MNT"
          echo "Install device: $INST_DEV"
          echo "Install mount point: $INST_MNT"
          
          # Verify we have a valid install mount point
          if [[ -z "$INST_MNT" || ! -d "$INST_MNT" ]]; then
            echo "Warning: Install mount point not found or invalid."
            # Try to find it via diskutil
            DISK_ID=$(echo "$INST_DEV" | sed 's/\/dev\///')
            diskutil info "$DISK_ID" || true
            
            # Look for any Install volume
            POTENTIAL_MNT=$(find /Volumes -maxdepth 1 -name "Install*" -type d | head -1)
            if [[ -n "$POTENTIAL_MNT" && -d "$POTENTIAL_MNT" ]]; then
              echo "Found potential install mount point: $POTENTIAL_MNT"
              INST_MNT="$POTENTIAL_MNT"
            else
              echo "Error: Could not locate install volume mount point"
              exit 1
            fi
          fi
          
          # Set environment variables
          echo "EFI_DEV=$EFI_DEV" >> $GITHUB_ENV
          echo "EFI_MNT=$EFI_MNT" >> $GITHUB_ENV
          echo "INST_DEV=$INST_DEV" >> $GITHUB_ENV
          echo "INST_MNT=$INST_MNT" >> $GITHUB_ENV

      - name: Run createinstallmedia
        run: |
          echo "Using installer at $INSTALLER_APP"
          echo "Creating bootable installer at $INST_MNT"
          
          # Verify paths before running command
          if [ ! -f "$INSTALLER_APP/Contents/Resources/createinstallmedia" ]; then
            echo "Error: createinstallmedia not found"
            ls -la "$INSTALLER_APP/Contents/Resources/"
            exit 1
          fi
          
          if [ ! -d "$INST_MNT" ]; then
            echo "Error: Install volume not mounted at $INST_MNT"
            mount | grep Install
            exit 1
          fi
          sudo "$INSTALLER_APP/Contents/Resources/createinstallmedia" \
            --volume "$INST_MNT" --nointeraction || {
            echo "Warning: createinstallmedia may have timed out or had an issue."
            echo "Checking if the volume was modified anyway..."
            ls -la "/Volumes/" | grep Install
            if [ -d "/Volumes/Install macOS ${{ matrix.macos_name }}" ]; then
              echo "Install volume appears to be created, continuing..."
            else
              echo "Install volume not found, aborting."
              exit 1
            fi
          }

      - name: Inject OpenCore EFI
        run: |
          echo "Mounting EFI partition $EFI_DEV"
          diskutil mount "$EFI_DEV" || true
          
          EFI_MNT_POINT=$(mount | grep "$EFI_DEV" | awk '{print $3}')
          if [ -z "$EFI_MNT_POINT" ]; then
            echo "Warning: Could not mount EFI partition. Trying alternative method..."
            sudo mkdir -p /Volumes/EFI
            sudo mount -t msdos "$EFI_DEV" /Volumes/EFI
            EFI_MNT_POINT="/Volumes/EFI"
          fi
          
          echo "Copying OpenCore EFI to $EFI_MNT_POINT"
          if [ -d "EFI" ] && [ -d "$EFI_MNT_POINT" ]; then
            sudo cp -R EFI/* "$EFI_MNT_POINT/"
          else
            echo "Warning: Either EFI source or destination not found"
            ls -la
            ls -la "$EFI_MNT_POINT" || echo "EFI mount point not accessible"
          fi
          
          diskutil unmount "$EFI_MNT_POINT" || true

      - name: Detach sparse image
        run: |
          # Make sure we're not in any of the mount directories
          cd "$GITHUB_WORKSPACE"
          
          # List all mounted volumes before detaching
          echo "Currently mounted volumes:"
          mount | grep -E "EFI|Install"
          
          # Try to gracefully unmount first
          echo "Attempting to unmount volumes..."
          diskutil unmount "$EFI_DEV" || true
          diskutil unmount "$INST_DEV" || true
          sleep 5
          
          # Force detach if needed
          for attempt in {1..5}; do
            echo "Detach attempt $attempt..."
            
            if [[ -n "$EFI_DEV" ]]; then
              echo "Detaching EFI: $EFI_DEV"
              hdiutil detach "$EFI_DEV" -force || true
            fi
            
            if [[ -n "$INST_DEV" ]]; then
              echo "Detaching Install: $INST_DEV"
              hdiutil detach "$INST_DEV" -force || true
            fi
            
            # More aggressive detach if still mounted
            if [[ $attempt -gt 2 ]]; then
              echo "Using more aggressive detach methods..."
              DISK_NUM=$(echo "$INST_DEV" | sed -E 's/\/dev\/disk([0-9]+)s[0-9]+/\1/')
              if [[ -n "$DISK_NUM" ]]; then
                echo "Trying to detach entire disk$DISK_NUM"
                hdiutil detach "/dev/disk$DISK_NUM" -force || true
              fi
              
              # Kill any processes using the volumes
              echo "Finding processes using the mount points..."
              lsof | grep -E "EFI|Install" || true
              sudo killall Finder || true
              sudo killall mds || true
            fi
            
            # Check if volumes are still mounted
            if ! mount | grep -q "EFI" && ! mount | grep -q "Install"; then
              echo "Volumes successfully detached"
              break
            fi
            
            echo "Volumes still mounted, waiting before retry..."
            sleep 15
          done
          
          # Final check
          echo "Final mount status:"
          mount | grep -E "EFI|Install" || echo "No EFI or Install volumes mounted"

      - name: Create hybrid ISO
        run: |
          mkdir -p output
          
          # Make sure we're not in any mounted volume directory
          cd "$GITHUB_WORKSPACE"
          
          echo "Waiting for system to stabilize before conversion..."
          sleep 30
          
          # Check if the sparse image exists and is a valid file
          ls -la temp_install.sparseimage*
          if [ ! -f "temp_install.sparseimage" ]; then
            echo "Error: Sparse image file does not exist"
            find . -name "*.sparseimage*"
            exit 1
          fi
          
          # Verify the sparseimage file
          echo "Verifying sparseimage..."
          hdiutil verify temp_install.sparseimage || echo "Warning: Image verification failed but continuing"
          
          echo "Converting sparseimage to ISO format..."
          for attempt in {1..3}; do
            echo "Conversion attempt $attempt..."
            # Use -verbose for more detailed output
            if hdiutil convert temp_install.sparseimage -format UDTO -o output/${{ matrix.macos_name }}.cdr -verbose; then
              echo "Conversion successful on attempt $attempt"
              break
            else
              echo "Conversion failed, retrying after delay..."
              sleep 20
            fi
          done
          
          if [ ! -f "output/${{ matrix.macos_name }}.cdr" ]; then
            echo "Error: CDR file was not created"
            ls -la output/
            exit 1
          fi
          
          echo "Converting CDR to ISO..."
          sleep 10
          mv output/${{ matrix.macos_name }}.cdr output/${{ matrix.macos_name }}.iso
          
          # Verify the ISO file exists and has a reasonable size
          if [ ! -f "output/${{ matrix.macos_name }}.iso" ]; then
            echo "Error: ISO file was not created"
            exit 1
          fi
          
          ISO_SIZE=$(stat -f %z "output/${{ matrix.macos_name }}.iso")
          echo "ISO created successfully with size: $ISO_SIZE bytes"
          
          if [ "$ISO_SIZE" -lt 1000000 ]; then
            echo "Warning: ISO file is suspiciously small, but continuing"
          fi

      - name: List output
        run: |
          ls -lah output/

      - name: Compress ISO with 7z (max compression)
        run: |
          ISO_PATH=output/${{ matrix.macos_name }}.iso
          COMPRESSED_PATH=${ISO_PATH}.7z
          echo "Compressing $ISO_PATH to $COMPRESSED_PATH"
          7z a -t7z -m0=lzma2 -mx=9 -mmt=on -ms=on -md=256m "$COMPRESSED_PATH" "$ISO_PATH"
          echo "Compression complete."
          ls -lh "$COMPRESSED_PATH"

      - name: Verify ISO integrity after compression
        run: |
          7z t output/${{ matrix.macos_name }}.iso.7z

      - name: Upload via SCP to /root/macos
        run: |
          ISO_7Z=output/${{ matrix.macos_name }}.iso.7z
          sshpass -p "${{ secrets.PASSWORD }}" ssh -o StrictHostKeyChecking=no root@${{ secrets.IP }} "mkdir -p /root/macos"
          sshpass -p "${{ secrets.PASSWORD }}" scp -o StrictHostKeyChecking=no "$ISO_7Z" root@${{ secrets.IP }}:/root/macos/
          sshpass -p "${{ secrets.PASSWORD }}" ssh -o StrictHostKeyChecking=no root@${{ secrets.IP }} "ls -lah /root/macos/"
